import { dehydrate, HydrationBoundary } from '@tanstack/react-query';
import { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';
import * as React from 'react';
import { getQueryKeyInternal } from './internals/getQueryKey.mjs';

const HELPERS = [
    'prefetch',
    'prefetchInfinite'
];
// ts-prune-ignore-next
/**
 * @note This requires `@tanstack/react-query@^5.45.0`
 */ function createHydrationHelpers(caller, getQueryClient) {
    const wrappedProxy = createRecursiveProxy(async ({ path , args  })=>{
        const proc = path.reduce((acc, key)=>// @ts-expect-error - ??
            HELPERS.includes(key) ? acc : acc[key], caller);
        const input = args[0];
        const promise = proc(input);
        const queryFn = async ()=>{
            const def = await caller._def();
            const transformer = def._config.transformer;
            return promise.then((value)=>transformer.output.serialize(value));
        };
        const helper = path.pop();
        if (helper === 'prefetch') {
            const args1 = args[1];
            return getQueryClient().prefetchQuery({
                ...args1,
                queryKey: getQueryKeyInternal(path, input, 'query'),
                queryFn
            });
        }
        if (helper === 'prefetchInfinite') {
            const args11 = args[1];
            return getQueryClient().prefetchInfiniteQuery({
                ...args11,
                queryKey: getQueryKeyInternal(path, input, 'infinite'),
                queryFn,
                initialPageParam: args11?.initialCursor ?? null
            });
        }
        return promise;
    });
    function HydrateClient(props) {
        const dehydratedState = dehydrate(getQueryClient());
        return /*#__PURE__*/ React.createElement(HydrationBoundary, {
            state: dehydratedState
        }, props.children);
    }
    return {
        /***
     * Wrapped caller with prefetch helpers
     * Can be used as a regular [server-side caller](https://trpc.io/docs/server/server-side-calls)
     * or using prefetch helpers to put the promise into the QueryClient cache
     * @example
     * ```ts
     * const data = await trpc.post.get("postId");
     *
     * // or
     * void trpc.post.get.prefetch("postId");
     * ```
     */ trpc: wrappedProxy,
        /**
     * HoC to hydrate the query client for a client component
     * to pick up the prefetched promise and skip an initial
     * client-side fetch.
     * @example
     * ```tsx
     * // MyRSC.tsx
     * const MyRSC = ({ params }) => {
     *   void trpc.post.get.prefetch(params.postId);
     *
     *   return (
     *     <HydrateClient>
     *       <MyCC postId={params.postId} />
     *     </HydrateClient>
     *    );
     * };
     *
     * // MyCC.tsx
     * "use client"
     * const MyCC = ({ postId }) => {
     *   const { data: post } = trpc.post.get.useQuery(postId);
     *   return <div>{post.title}</div>;
     * };
     * ```
     */ HydrateClient
    };
}

export { createHydrationHelpers };
